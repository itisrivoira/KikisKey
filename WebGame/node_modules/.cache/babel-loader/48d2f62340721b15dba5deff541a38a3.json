{"ast":null,"code":"// cheap lodash replacements\n\n/**\n * drop-in replacement for _.get\n * @param obj\n * @param path\n * @param defaultValue\n */\nexport function get(obj, path, defaultValue) {\n  return path.split('.').reduce((a, c) => a && a[c] ? a[c] : defaultValue || null, obj);\n}\n/**\n * drop-in replacement for _.without\n */\n\nexport function without(items, item) {\n  return items.filter(i => i !== item);\n}\n/**\n * drop-in replacement for _.isString\n * @param input\n */\n\nexport function isString(input) {\n  return typeof input === 'string';\n}\n/**\n * drop-in replacement for _.isString\n * @param input\n */\n\nexport function isObject(input) {\n  return typeof input === 'object';\n}\n/**\n * replacement for _.xor\n * @param itemsA\n * @param itemsB\n */\n\nexport function xor(itemsA, itemsB) {\n  const map = new Map();\n\n  const insertItem = item => {\n    map.set(item, map.has(item) ? map.get(item) + 1 : 1);\n  };\n\n  itemsA.forEach(insertItem);\n  itemsB.forEach(insertItem);\n  const result = [];\n  map.forEach((count, key) => {\n    if (count === 1) {\n      result.push(key);\n    }\n  });\n  return result;\n}\n/**\n * replacement for _.intersection\n * @param itemsA\n * @param itemsB\n */\n\nexport function intersection(itemsA, itemsB) {\n  return itemsA.filter(t => itemsB.indexOf(t) > -1);\n}","map":{"version":3,"mappings":"AAAA;;AAEA;;;;;;AAMA,OAAO,SAASA,GAAT,CAAgBC,GAAhB,EAA0BC,IAA1B,EAAwCC,YAAxC,EAA4D;AAClE,SAAOD,IAAI,CACTE,KADKF,CACC,GADDA,EAELG,MAFKH,CAEE,CAACI,CAAD,EAAIC,CAAJ,KAAWD,CAAC,IAAIA,CAAC,CAACC,CAAD,CAAND,GAAYA,CAAC,CAACC,CAAD,CAAbD,GAAmBH,YAAY,IAAI,IAFhDD,EAEuDD,GAFvDC,CAAP;AAGA;AAED;;;;AAGA,OAAO,SAASM,OAAT,CAAoBC,KAApB,EAAgCC,IAAhC,EAA8C;AACpD,SAAOD,KAAK,CAACE,MAANF,CAAcG,CAAD,IAAOA,CAAC,KAAKF,IAA1BD,CAAP;AACA;AAED;;;;;AAIA,OAAO,SAASI,QAAT,CAAkBC,KAAlB,EAAuC;AAC7C,SAAO,OAAOA,KAAP,KAAiB,QAAxB;AACA;AAED;;;;;AAIA,OAAO,SAASC,QAAT,CAAkBD,KAAlB,EAAuC;AAC7C,SAAO,OAAOA,KAAP,KAAiB,QAAxB;AACA;AAED;;;;;;AAKA,OAAO,SAASE,GAAT,CAAwCC,MAAxC,EAAqDC,MAArD,EAAuE;AAC7E,QAAMC,GAAG,GAAG,IAAIC,GAAJ,EAAZ;;AACA,QAAMC,UAAU,GAAIX,IAAD,IAAa;AAC/BS,OAAG,CAACG,GAAJH,CAAQT,IAARS,EAAcA,GAAG,CAACI,GAAJJ,CAAQT,IAARS,IAAgBA,GAAI,CAACnB,GAAJmB,CAAQT,IAARS,IAA2B,CAA5CA,GAAgD,CAA9DA;AACA,GAFD;;AAGAF,QAAM,CAACO,OAAPP,CAAeI,UAAfJ;AACAC,QAAM,CAACM,OAAPN,CAAeG,UAAfH;AAEA,QAAMO,MAAM,GAAQ,EAApB;AACAN,KAAG,CAACK,OAAJL,CAAY,CAACO,KAAD,EAAQC,GAAR,KAAgB;AAC3B,QAAID,KAAK,KAAK,CAAd,EAAiB;AAChBD,YAAM,CAACG,IAAPH,CAAYE,GAAZF;AACA;AACD,GAJDN;AAKA,SAAOM,MAAP;AACA;AAED;;;;;;AAKA,OAAO,SAASI,YAAT,CAAyBZ,MAAzB,EAAsCC,MAAtC,EAAwD;AAC9D,SAAOD,MAAM,CAACN,MAAPM,CAAea,CAAD,IAAOZ,MAAM,CAACa,OAAPb,CAAeY,CAAfZ,IAAoB,CAAC,CAA1CD,CAAP;AACA","names":["get","obj","path","defaultValue","split","reduce","a","c","without","items","item","filter","i","isString","input","isObject","xor","itemsA","itemsB","map","Map","insertItem","set","has","forEach","result","count","key","push","intersection","t","indexOf"],"sources":["/home/stud5c/Scrivania/KikisKey/WebGame/node_modules/dnd-core/src/utils/js_utils.ts"],"sourcesContent":["// cheap lodash replacements\n\n/**\n * drop-in replacement for _.get\n * @param obj\n * @param path\n * @param defaultValue\n */\nexport function get<T>(obj: any, path: string, defaultValue: T): T {\n\treturn path\n\t\t.split('.')\n\t\t.reduce((a, c) => (a && a[c] ? a[c] : defaultValue || null), obj) as T\n}\n\n/**\n * drop-in replacement for _.without\n */\nexport function without<T>(items: T[], item: T): T[] {\n\treturn items.filter((i) => i !== item)\n}\n\n/**\n * drop-in replacement for _.isString\n * @param input\n */\nexport function isString(input: any): boolean {\n\treturn typeof input === 'string'\n}\n\n/**\n * drop-in replacement for _.isString\n * @param input\n */\nexport function isObject(input: any): boolean {\n\treturn typeof input === 'object'\n}\n\n/**\n * replacement for _.xor\n * @param itemsA\n * @param itemsB\n */\nexport function xor<T extends string | number>(itemsA: T[], itemsB: T[]): T[] {\n\tconst map = new Map<T, number>()\n\tconst insertItem = (item: T) => {\n\t\tmap.set(item, map.has(item) ? (map.get(item) as number) + 1 : 1)\n\t}\n\titemsA.forEach(insertItem)\n\titemsB.forEach(insertItem)\n\n\tconst result: T[] = []\n\tmap.forEach((count, key) => {\n\t\tif (count === 1) {\n\t\t\tresult.push(key)\n\t\t}\n\t})\n\treturn result\n}\n\n/**\n * replacement for _.intersection\n * @param itemsA\n * @param itemsB\n */\nexport function intersection<T>(itemsA: T[], itemsB: T[]): T[] {\n\treturn itemsA.filter((t) => itemsB.indexOf(t) > -1)\n}\n"]},"metadata":{},"sourceType":"module"}